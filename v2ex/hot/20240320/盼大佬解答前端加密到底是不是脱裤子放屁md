### 盼大佬解答，前端加密到底是不是脱裤子放屁？

闲暇之余，探索了一个小伙伴的开源网站，无意中发现了他的修改密码接口，是明文传输的，如下图。

![6361710921930_.pic_bvfob1_.jpeg]( https://cdn.jsdelivr.net/gh/lewkamtao/PicHub-Cloud@master/GeekBlog/6361710921930_.pic_bvfob1_.jpeg)

后来我跟他反应了这个问题，我的观点是应该在前端 md5 加密一下，他说，他在后端做了加密处理，明文传输没问题，网站是 https ，前端加密不就等于脱裤子放屁吗？

和他几番讨论之后，无果，也有几个小伙伴觉得前端加密等于自己骗自己。

我经验比较单薄，以至于没有什么实际上的论点去论证，希望有大佬解答一下，这种场景在前端加密有没有意义。

---------------------------------------------------

HTTPS 加密的情况下，如果密码以明文形式发送，那么在服务器端（如果被攻击者侵入）仍然可以看到密码的明文

---------------------------------------------------

https 的话前端再加一次密确实没啥意义

---------------------------------------------------

网站是 https ，前端加密不就等于脱裤子放屁吗

---------------------------------------------------

1. md5 是摘要算法不是加密算法
2. 你在前端加密是想取得什么样的结果？是想提高安全性？还是防脚本小子？前者加不加密都一样，后者还是能防一些小白的

---------------------------------------------------

@justFxxk2060 如果服务器端被攻击那你密码不是怎样都会泄露吗？

---------------------------------------------------

QA 说我的表单密码没加密，然后我 btoa 一下就糊弄过去了。

---------------------------------------------------

@V2April  这种情况下，他拿到的只是 md5 ,也就是你这个网站密码可能丢失，不一定影响用户的其他账号。

---------------------------------------------------

@V2April 只是你的密码的 md5 被泄漏了，你的密码没泄漏，像我很多平台同密码的。

---------------------------------------------------

HTTPS 只保证通信过程的安全，不保证服务器上数据的隐秘性。
前端加密可以防住很多脚本小子，但如果真要爬，分析分析还是能爬的

---------------------------------------------------

他说的对

---------------------------------------------------

伺服器端被攻擊者侵入，攻擊者直接替換前端為他自己寫的前端，這樣前後端都是攻擊者掌控了，明文密文都無救.

---------------------------------------------------

有点用但不多，防中间人（比如公司电脑加域，签根证书）偷密码，然后猜测你其他网站的密码（无聊的人）

---------------------------------------------------

加密信道明文传本身没问题，但需要注意衍生的风险，比如日志暴露明文密码之类的，

Google 都是直接传的，我觉得可以终结这个讨论。

---------------------------------------------------

加密这个词不对, 也不该用 md5. 应该用 sha256 哈希一下, 为了密码明文不对服务端暴露. 同时, 服务端应该加盐再哈希一次, 为了防止彩虹表撞库

---------------------------------------------------

https 报文前端加密确实是脱裤放屁呀. 

换个角度来说, https 其实就是保证传输通道在某种程度上的可靠性, 如果你客户端或者是服务器都被挂马了, 那传输过程加不加密又有什么用呢

---------------------------------------------------

你密钥放在前端加密有啥意义？自己骗自己？

---------------------------------------------------

有用但不多，基本等于脱裤子放屁

---------------------------------------------------

@justFxxk2060 
@userKamtao 
#7 #8
不敢苟同，你都攻破服务器了，替换个静态资源很难吗？我直接替换个不加密的页面不就行了？

---------------------------------------------------

@musi  你替换静态资源可能能欺骗一点时间内的用户密码。
如果你记录日志，你可以长期拿到明文（ md5 ）

---------------------------------------------------

都用了 https 了，再加密不就相当于自己骗自己吗

---------------------------------------------------

之前公司的前端是对参数做 aes 加密，后端解密，只是相对破解门槛较高而已。还有密码应该要加密也不会用 md5 这种不可逆的方式吧，不然密码规则后端怎么校验

---------------------------------------------------

这还有啥可讨论的。。

---------------------------------------------------

@justFxxk2060 #19 我只需要把加密部分的代码删掉就行了，为什么只能欺骗一段时间内的用户密码。

---------------------------------------------------

90%的业务情况是没必要的，因为 https 足够安全。

但是，如果你客户端浏览器装了恶意证书，那么请求的内容就会暴露。

所以你可以自生成一对证书，在发送前用证书加密，后端拿到后用私钥解密，在一定程度上能避免这个问题

---------------------------------------------------

是

---------------------------------------------------

在 https 的前提下，前端进行散列或者签名的唯一积极意义是防止初级选手来刷接口或者简单的重放攻击

除此以外不具有什么太大的积极意义。

---------------------------------------------------

@musi  你需要改动前端，然后需要反编译后端的代码/服务，逻辑，然后再编译回来，然后还需要部署。这个工作量会不会很大？

---------------------------------------------------

看目的是什么，防密码泄露是用处不大，但是请求体、响应体非对称加密再加上 JS 混淆 vmp 加固对防脚本逆向还是有一点点用的

---------------------------------------------------

@nobject "还有密码应该要加密也不会用 md5 这种不可逆的方式吧"

就是要不可逆，才能防止内鬼拿用户数据去卖钱啊。

---------------------------------------------------

用后端传过来的盐算摘要后传回去，数据库只存 salt 和密文，传输过程中也只有 salt 和密文

---------------------------------------------------

1. md5 不叫加密。
2. 仅用 md5 也起不到保护密码的作用，请搜彩虹表。
3. 1 楼说那种情况，一般是指数据库泄露了，导致用户的密码被泄露。 但是楼主正文提到了， 后端说处理过了。
4. 确实是脱裤子放屁。

---------------------------------------------------

@justFxxk2060 #27 有没有可能我只需要通过前端代码反推出加密逻辑就行，在后端服务前面再套一个服务负责加密用户名密码，在了解了加密逻辑后这一套下来不是快的很

---------------------------------------------------

处理不好的话，员工 debug 的时候记一下 log 里的密码再简单不过了。

---------------------------------------------------

但如果不加密，那意味着服务端可以拿到用户明文的密码，用户隐私这方面是不是也值得去考虑呢？

---------------------------------------------------

@1iuh 如果那是一个独立开发者开发的网站，用户多平台密码一样，服务端不就可以知道用户密码了？

---------------------------------------------------

不是脱裤子放屁。

可以防止无意泄露和二次伤害。比如打 debug 日志可能会无意间把用户输入打到日志里，这样会泄露用户密码明文。

还有黑客流量复制攻击，不是所有攻击都会改代码的，有种攻击是观察者模式，只在网络层增加一个转发插件把流量全部转发给自己。如果用户提交了明文密码，那密码就会泄露。如果是前端摘要过的，那只会泄露 hash 。

---------------------------------------------------

不要明文，隐私合规问题。如果明文传输你可能在任意环节暴露出用户的真是密码。如果操作不当你的员工甚至可以拿到密码加用户手机号登录任何设置此密码的网站。在一个如果用户是明文，这样的记录会出现在日志，代理多个地方。所以密文是必须的，不在安全，旨在合规

---------------------------------------------------

@flyhaozi 感谢回答！但是我觉得防密码泄漏就是防所有人，包括服务端本身，服务端不应该直接能拿到用户的密码。

---------------------------------------------------

前端密码加密确实没有意义, 如果 md5 加密, 实际上 md5 的密码就可以当成密码, 为了防止密码在传输过程中被监听, 使用 https 即可. 前端加密通常是为了混淆接口请求参数, 防止爬虫, 当然也只是防君子不防小人.

---------------------------------------------------

@google2020 这位绝对是大佬，看 id 就知道了。

---------------------------------------------------

1. 鉴权：密码本身是不安全的，因为用户的各种不安全的做法。所以现在都建议使用两步验证，短信登录等 OTP 。甚至现在直接使用 passkey 替换密码。
2. 泄露：所有的安全建议都说过不要重复使用密码。如果没用，加密无所谓。如果用了，一个应用加密没有任何用。

敲一半才发现只有一点，其实应用加不加密是无所谓的，完全取决于用户习惯。

---------------------------------------------------

@userKamtao 你又没办法限制独立开发者一定要在前端做哈希，独立开发者想要拿你密码当然可以拿。我们讨论的话题是在 https 的前提下， 前端不做加密是否安全。  后端会偷密码或者日志输出密码这种都是属于系统内部的问题，就算要求前端做哈希，那前端还能在哈希之前把密码存下来，这种问题讨论没有意义。

---------------------------------------------------

@1iuh 你说的好像也有道理，如果是小人，前端页面也可以拿到密码。

---------------------------------------------------

看你怎么加密

如果你在前端实现了对称加密，那么就无意义。

如果你在前端代码里面 实现了 RSA 加密 那么加密还是有意义的

---------------------------------------------------

要哈希的，md5 是摘要算法，不是加密，加密是可逆的，可以解密，摘要是不可逆的，单向的。

为什么要哈希密码之后再传输，主要是 防止明文泄露，即使最差的情况，被拖库了，也只能获取到哈希的密码，而不能得到明文，因为明文密码可以用于撞库，而哈希不可以，因为不同的网站往往对密码的处理不同，比如，有些网站会加盐后哈希，这样即使大家用的同一种哈希算法，因为盐的存在也只会影响该用户在本网站的安全，而不会影响到用户其他的网站（很多用户多个网站的密码往往是一样的。）。

---------------------------------------------------

前端那不叫加密，那叫摘要（毕竟你不能把加密代码和密钥放在前端），这种情况后端存的应该也是摘要。

只能说不是没有用，有一点用。
比如有中间人攻击啥的，用户无视证书有问题之类的，这种就算是 https 请求，也会被看到请求内容；但是这种情况，会的人也会看你前端的摘要算法，然后找相应库去撞。
或者明文密码进入后端的时候，后端设计上只要想，就能看到明文密码，那这样对用户来说是不公平的。

---------------------------------------------------

用非对称加密算法，前端用公钥加密是有意义的

---------------------------------------------------

为什么 v 站一提到前端加密就扯 https?
这两者有半毛钱关系吗？

---------------------------------------------------

18 年的时候，我就问过这个问题： https://www.v2ex.com/t/466847

---------------------------------------------------

你为什么不直接参考大型网站的做法呢？比如 Github

![image]( https://github.com/gkd-kit/gkd/assets/38517192/55fe92b8-1437-4050-bf90-18e73d6c458f)

---------------------------------------------------

@somebody1 
补充，前面没答到电子上。

网络安全是有木桶效应的，也就是最薄弱环节。如果前端不加密，则中间人攻击或者从流量中可能可以逆向出明文密码。这拖累了网站整体的安全。

只要有任一环节可以获取到明文（在网络中，存储中），就极有可能发生泄露。

---------------------------------------------------

至于前端 hash ，毫不客气的说就是脱了裤子放屁。

---------------------------------------------------

@lisongeee 好家伙 这个可以

---------------------------------------------------

@userKamtao #7 多平台同密码泄露影响到你是因为泄露你密码的平台直接存的明文，而不是因为传输过程是明文，这两者区别大了去了

---------------------------------------------------

要传输的数据是不是密码，完全是两个不同的问题。

「密码」就是要原地消灭，只传 hash 后的值，尽可能的减少暴露密码的可能。

---------------------------------------------------

举个例子给你说吧，某项目的登录验证是这样的：
​
1. 密码控件自身生成一个随机数 C ，并从 webserver 获取一个随机数 D 。
2. 密码控件将 C 、D 组成一个新的对称密钥 CD 。
3. 密码控件用密钥 CD 对输入的 X 进行对称加密，获得加密结果 Y 。
4. 密码控件使用非对称公钥 G 对 C 进行加密，产生加密结果 E 。
5. 将 Y 和 E 传送给 webserver 。
6. webserver 解密 E 得到 C,从而得到 CD
7. 通过 CD 解密 Y 得到 X
8. 调用 XX 算法计算 hash ，得到 A
9. A 与数据库存储的 B 比对，一致则验证通过。

无论是传输过程中的 Y 、E 泄漏，还是服务器上存的 F 泄漏，都无法推演得到用户真正输入的 X 。所以你说有用没呢

---------------------------------------------------

比较建议传递密码明文至后端, 后端自行 HASH 后存储. 
启用了 HTTPS, 如果没有合规要求, 可直接传明文, HTTPS 就是保证传输安全的; 如果有合规性要求, 则按要求对密码进行前端加密处理. 前端加密虽然可破解, 但可以挡住大部分攻击者.

---------------------------------------------------

@userKamtao 在以前 https 不那么流行，运营商劫持 http 的时候，好多站点都是前端 rsa 加密的。淘宝，金山这些都是。后面 https 普及了，基本都是明文了。泄漏密码和前端加不加密关系不大。

---------------------------------------------------

我前端再混淆一下，加密就能刷掉一大把二把刀的人，意义还是有的

---------------------------------------------------

我在网吧忘了下机, 被后面坐我那的程序员盗了密码
我工位忘了锁屏, 被坐在旁边的同事拿到了密码
我使用了代理软件, 我电脑到代理之间不是 tls
......

---------------------------------------------------

@V2April 有意义的，对于同账号服务器只存储加盐的密码 hash ，客户端 hash 后再发送密码，可以确保用户在该网站密码泄露的同时此密码无法被用于撞其它网站的账号

---------------------------------------------------

密码学经典之不要自己设计加密算法

---------------------------------------------------

问题有点多，随便指出一点吧。

你说 "我的观点是应该在前端 md5 加密一下"

首先 md5 是一个 hash 算法，直接将这个 hash 值传给后端，后端没办法逆向回去，一些业务比如判断密码的复杂度做不了。

---------------------------------------------------

如果你把各方面可能的参数和漏洞都考虑了一遍，你最终会发现你要把 https 重新实现了一遍。

---------------------------------------------------

@musi #18 认同你的看法，但凡是泄露，不论是不是 md5 后的结果，都可以伪造请求拿 token 之类的操作了

---------------------------------------------------

@lyy780808 谢谢大佬，但是这个判断复杂度其实，可以在前端做，后端不需要知道我的密码是什么，这样会安全很多。

---------------------------------------------------

你要不再写一个 https 呗

---------------------------------------------------

考虑隐私，不应该明文传输密码

---------------------------------------------------

@justFxxk2060 #7 那也应该在后端加密的好吧 前端加密就是无用功 而且 md5 严格意义上来说并不算加密算法

---------------------------------------------------

@RightHand 中间人攻击 https 就能阻止好吧

---------------------------------------------------

你说服务端拿到明文密码就不太对，这种都不需要你去考虑的，服务端要做的是加密一旦存入数据库就不可能有明文，没有人知道这个用户的明文是什么，目前在我看来 95%以上的系统前端都是直接明文传的， 如果是前端做处理那就会被知道这个系统用了什么加密算法，这也是一个隐患。

---------------------------------------------------

不需要加密，你可以学习一下 https 的原理和对应解决的问题

---------------------------------------------------

我更喜欢加密的，因为中间可能有 CDN ，虽然 CDN 是可信中间人，但是多一层保险比没有好。

---------------------------------------------------

@userKamtao #66 你是真离谱呀兄弟！ 按你这思路 啥判断都能在前端做？那你这个判断复杂度是不是能被轻松跳过？ 并且 hash 这种无法逆向的算法，你给后端传个这玩意 你让后端怎么处理？ 离大谱！！！  理论上 https 的网站不用做前端加密，事实上很多大厂的页面已经是这样做的（那些说中间人攻击的，可以开启 HSTS 并加入 HSTS Preload List ，双向认证，HPKP 等，除非你电脑中病毒等情况  这谁都没办法）。 就算要做加密 那也要选可逆的算法呀 比如双向 RSA 加密，否则后端拿不到实际值有啥用。。。

---------------------------------------------------

google 登录也是明文传输的，也就用了 https

---------------------------------------------------

你前端加不加密都无所谓，反正不管你传的是明文还是密文，后端都一定要对你传过来的东西先加盐然后再做加密，然后再存到数据库里，只是你传密文的话，一些密码合规性的判断，后端就没法做了

---------------------------------------------------

的确是脱裤子放屁   OP 再提高一下姿势水平

---------------------------------------------------

@K120  其实服务端没有任何地方需要用到用户的密码，直接存储 md5 后的字符串即可，md5 不可逆，为什么还要加密算法呢？

---------------------------------------------------

安全是多环节的，多一个环节不是坏事，还可以增加用户对网站安全性的信心。
你也可以不加密，但是你会遭到用户质疑，用户会觉得你是不是在后台明文存他的密码了。
我记得 Github 有的表单就没加密，具体记不得了，好像在 hacker news 上刷到过。
加个密屁大点事，建议别偷懒了。和用户为这个扯皮挺没劲儿的。

---------------------------------------------------

@eber 为什么要拿用户密码？你为什么要知道用户的密码是什么呢？滑天下之大稽

---------------------------------------------------

const params = {
        account: encryptByDES(account.value),
        cellPhone: encryptByDES(cellPhone.value),
        password: encryptByDES(password.value),
        name: encryptByDES(name.value),
      };    你想要这种东西吗？？？这种只是看起来是加密的而已，就是从 f12 看不出明文，但是防君子不防小人，只要到到通过 f12 在 js 文件里面去搜索，相关代码和加密用的 key 一目了然，有的甚至还会有对应的 decryptByDES 方法。那有啥实质意义。

---------------------------------------------------

@kneo 我觉得没有几个用户会关心这种事情。甚至没有几个用户去真正关心 ui 。

---------------------------------------------------

上面一堆程序怪咖觉得 https 就是一切，还有说 md5 不是加密的，我扔一串 md5 给你，你一个星期解的出来不？就说这最经典的场景： 前端日志上报，一般都会抓接口请求参数，你告诉我日志后台都是明文是吧？一看公司内部就没安全扫描机制，不然就是一个 p0 的安全问题！

---------------------------------------------------

可以，但没必要。硬说有什么意义的话，那就是加大了工作量，能消磨时间

---------------------------------------------------

@userKamtao 不可逆的算法得出的密文密码给后端密码合规怎么判断？并且我不光说密码 我说所有的数据，不同数据后端可能需要不同的校验都传不可逆的给后端有啥用？ 就算要加密也要用类似两套 RSA 的方式。你真的需要再提高一下姿势水平，如果不是姿势水平低我都怀疑你这话题是来骗币的！！！

---------------------------------------------------

@996jiucai  没理解我意思，我的意思是前端对用户输入的密码直接 md5 ，后端直接用 md5 后的字符串。登录和注册皆是如此。

---------------------------------------------------

@rrfeng 只传输 hash 相当于在当前站点 hash 就是密码。

---------------------------------------------------

除非前端不用可以反编译的语言编写，否则就是脱裤子放屁。

---------------------------------------------------

HTTPS.HTTPS,好像用了 https ，就可以包打天下了、

那么 HMAC ，SRP 这些设计的协议也是多余？

---------------------------------------------------

@Seria 我感觉应该没有隐私什么事情，前端对字段加密，一般也就是做个对称加密，而且前端代码对任何用户都是可见的。 对称加密 + 代码可见 = 没有隐私。

---------------------------------------------------

@eber 不是，注册时候数据库存储了前端传过来的 md5("123456")，登录传输的 md5("123456")字符串，这两个字符串，不能比对吗？你非要逆出来 123456 才能判断是吧？

---------------------------------------------------

@userKamtao 你放十万个心，99.9%的企业就算最终入库的密码也不会是不可逆算法保存的。  你但凡别提 md5 都没那么离谱。前端加密也不是脱裤子放屁，两份双向 RSA 就能解决可靠性。99.9%的企业无论什么数据服务端必须能逆向成明文。

---------------------------------------------------

@userKamtao 后端库对密码字段存的本来就是 md5 ，不论前端做不做安全。后端的安全性不会依赖前端

---------------------------------------------------

@eber 大佬，我就单讨论密码这一个场景，密码也需要逆向？

---------------------------------------------------

@userKamtao 最简单的需求密码规则校验怎么实现呢？你考虑的太片面，产品要多方面考虑的。

---------------------------------------------------

肯定不是，加密是为了提高破解的成本，前端随便搞个加密就能过滤 80% 的脚本小子。看你网站的价值了，如何被高手盯上，上啥加密也不行

---------------------------------------------------

站在一个安全的角度来说，前端加密多了一道墙，如果不加密比如说在一个网吧用户登录后上来一趟测试，一位懂点技术的 F12 就能看到这个用户的信息了。

---------------------------------------------------

什么日志上报不安全，开发不当回事非要把密码忘外送哪个端拦不住

---------------------------------------------------

早些年都用 http 的时候是有意义的，毕竟是明文传输。印象中当年校内/人人的密码登录是 http+RSA 加密。这儿的加密，或者 https 的意义是在于传输安全。
存储（数据库）中应该存哈希而非明文也是有意义的，避免数据库被脱裤后泄露密码。当然，这和前端加密无关。

但是，上面有一些人提到说前端加密/哈希可以应对服务器被黑后导致用户密码泄露的情况。笑死，如果我都能完整控制你的服务器了，你之前怎么做有关系吗？我反正能改成让用户直接提交明文。


@dudubaba 『还有说 md5 不是加密的，我扔一串 md5 给你，你一个星期解的出来不？』彩虹表了解一下。加密和哈希的区别也是常见的区分科班和非科班的方法。

---------------------------------------------------

脱裤子放屁，是为了放置放屁崩出屎。

---------------------------------------------------

@userKamtao md5 聊胜于无。它的问题：

第一，md5 的输入和输出是多对一的关系，对无限数据来说当然不可逆，但是用户密码都是短数据，你如果把用户密码显示在比如 16 位 ascii 字符的范围内，在这个有限的输入集里，碰撞相当少，可以认为是“可逆”的。

第二，md5 属于很落后的算法，应该是有方法可以暴力逆向的。学术方面的研究我就不花时间搜了。即使是普通用户也可能通过 md5 库查询到原始密码（即使你加过盐）。

第三，即使 md5 是不可逆的，它有一个特性，就是同样的密码，md5 结果一定是一样的。如果有人捕获了你传过去的 md5 ，下次就可以用这个 md5 登录。这就相当于一个永久性的 token 。一个好的加密算法应该每次都生成一个不一样的，不能重用的 token 。

---------------------------------------------------

打个比方，你们公司的运维想窃取用户密码，但他没有 dba 权限，如果明文，他就可以在服务器日志获得。

---------------------------------------------------

@996jiucai 没错，一般用户不会看这个。但只要有一个用户注意到了可能就会晒到网上然后变成扯皮。有人可能觉得没必要浪费时间实现这个功能，我的角度是没必要浪费这个时间扯皮。

---------------------------------------------------

@kneo #101 第三很对，相当于把密码从人类可读转换为无意义的密码，依旧是明文密码与后端通信。

简单的前端加密可以认为是脱裤子放屁。
合理的加密是前后端配合，以保证每次通信或者每个会话期间是不同的加密结果。

---------------------------------------------------

这个问题我深入研究过，对于秘钥的传输，正确且安全的做法是前端使用慢 hash ，后端使用快 hash 。

前端慢 hash 用于防止暴力撞库。后端快 hash 则是为了防止数据库，日志等被非法入侵或者数据泄露等造成的秘钥泄露问题。

---------------------------------------------------

@kneo  你说得不无道理，如果是一个钓鱼网站，前端代码在他那，想钓你的密码，也是很简单的。主要还是防止服务端，如果是很乱的公司，指不定有屌毛把明文输出到日志，然后把日志发给外包排查。

---------------------------------------------------

不要用  md5 , 要用就用 argon2

---------------------------------------------------

此贴终结吧！这帖子说来说去就俩问题：
1. 首先从能不能破解这一层来说：前端加密不算脱裤子放屁，因为两套 RSA 可以保证无法在前端被破解。

其次讨论你这个离谱前端 md5 传值到服务端的问题

2. 无论业务场景是否需要前端加密 都不应该选择前端 md5 传给后端，应该选 1 中的方式。
3. 从企业的角度考虑任何到服务端的数据都应该能被服务端计算出实际值，所以还是选择 1 中的方法。

---------------------------------------------------

@luoway 第三点，那就算不是 md5 加密，有人捕获你的密码也一样能重复登录；这里使用 md 加密的逻辑是，不让别人知道你的密码，然后去其他平台登录，我是这个意思。

---------------------------------------------------

@shakoon 客户端 C 可能泄露，请求获取的 D 可能泄露。CD 对称加密 X 。弯弯绕绕可能复杂了一点。唯一有用的是 非对称的 G, 加密了 C 传送给了服务端

---------------------------------------------------

我发现我平常访问的知名网站都是明文传输密码的

---------------------------------------------------

你先调研看看那些大厂比如 google 微软的密码是咋传的，而不是啥都没研究过全凭自己想象就去指挥

---------------------------------------------------

加密可以有效防止脚本

---------------------------------------------------

基于用户角度考虑是有用的, 服务器被黑了，也没法捕获到真实密码（除非暴力计算）

---------------------------------------------------

@Kaiv2 坏处就是如果有多端登录需求，都需要统一算法

---------------------------------------------------

@Ritr 现在有很多可以调用 Chrome devtools 的库了，直接模拟用户输入和鼠标点击操作，所以针对防止自动化脚本这个层面没啥用。你自己可以试一下这个 - chromedp 库

---------------------------------------------------

@mxT52CRuqR6o5  大佬，你别生气，因为谷歌和微软业务需要在浏览器记录你的登录密码。

---------------------------------------------------

@userKamtao #94 后端在很多场景下需要拿到 明文密码的，就最简单的例子就是校验密码是否复合规则，长度、大小写一类的，这个校验的事儿肯定不能只放到前端做，然后你前端给 md5 了后端就没法校验了都

---------------------------------------------------

不管是传输还是处理端，都应该避免出现明文密码。

1. 比如你能够通过 F12 看到传输的密码明文就是不合理的（当别人用你的电脑时就可能看到）；前端（ app/浏览器等）应该对输入的密码编码/加密传输，具体方式根据系统安全要求实施，比如从安全性低到高：baseN 编码、哈希算法、对称加密、非对称加密。如安全要求较高，则还可以使用二进制协议如 protobuf 传输数据，杜绝通过 F12 查看到可读文本的可能。

2. 后端一般收到的是处理过的密码文本（不应该能逆推出明文），比如哈希、或加密过的哈希，二次处理（可能需要解密）后再将其写入 db 或与 db 存储的密文进行匹配验证。（ db 存储的一般是密文二次加盐后的字符串，不应该是明文密码）

这样前端后端都无法获得密码明文，将密码暴露的风险降到最低。

---------------------------------------------------

属实没必要
1. 假如你们这项目就是个蜜罐专门骗用户密码的，那没必要搞这个
2. 如果你们是正常项目，后端拿到明文就加盐加密了，怎么泄漏，也没必要搞这个

用户已经被教育不要在多个网站用相同密码了，如果你还想提高安全性，上 mfa

---------------------------------------------------

没必要，但是有用。在大公司里这么做，安全部门直接给你提低危，修不修是你的事，和安全部门掰扯就行。

---------------------------------------------------

黑客在任何一个环节都有攻击可能，而且成功进去也不会总是完全控制，很多时候就是只能读，但这已经是很大的问题了，因为只要能读就意味着脱裤可能。安全部门要是这么跟你扯，肯定还是得修
@voidemoer

---------------------------------------------------

我插一句脱裤子放屁 比穿裤子放屁要爽的多，特别是闷屁

---------------------------------------------------

前端加密是为了防止中间人攻击时泄露明文密码，其他感觉意义不大。

---------------------------------------------------

有点用，至少我见到的攻击短信接口大部分都是未经过任何加密的，稍微处理下提升一点点难度就可以让很大一部分攻击者放弃。除非你真的很有价值，值得破解

---------------------------------------------------

我不知道你和那些认为后端有必要拿到明文密码原始值的人有什么交流的必要。
从这个角度来说，只要后端能拿到明文密码原始值，那些什么 rsa 之类的确实就是脱裤子放屁。

---------------------------------------------------

别说 op ，就是 CSDN 这种专业网站，不也是数据库明文保存的密码吗，程序员的弱//智行为永远比你想的还要弱//智一万倍，其实 op 说的没什么问题，业内早期的做法是 md5 ，不过改了，后来基本改为了①加盐+②md5 ，这样可以保证服务端也不会知道用户的密码，而且保证传送过程中的安全，其实为什么不要单纯的 md5 ，因为容易撞库，就是已经有大量的 md5 密码的对照表了，大部分的密码是可以直接通过 md5 数据库反查出密码，另外如果你直接明文传送，那别人可以知道你程序的处理密码的逻辑，其实这是一种风险，https 这个其实很多人没搞明白，https 不是绝对安全的，依然会有伪造证书的可能，抓包也不是不可能，也就是依然会有中间人攻击的几率。

---------------------------------------------------

送给你 对称/非对称以及公钥基础知识。

https://www.thebyte.com.cn/http/https.html

---------------------------------------------------

是不是脱裤子放屁不知道，反正谷歌微软苹果 fb 都是明文传密码

---------------------------------------------------

1. 需要散列，但不是 MD5 SHA 之类的常规通用散列，用 Argon2 ，Bcrypt 之类的专用散列
2. 主要是防止少量特殊情况，比如用户遭到中间人攻击（说的就是企业网络）、以及上面说的打 log 泄露

---------------------------------------------------

@gam2046 正解

---------------------------------------------------

你比他正确一点，但还不够正确，可以阅读 https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html

---------------------------------------------------

这块好像讨论过多次了，结论是有意义，聊胜于无。

---------------------------------------------------

用户修改的密码你用不可逆的算法传输，那么数据库怎么存进去呢

---------------------------------------------------

op 要相信自己的判断，虽然安全只是相对的，你要做的是把风险一步步降低，你永远挡不住人为的低级失误，业内为什么要加密，绝不是脱裤子放屁，就像前面的说的，如果你服务器被攻破，或是流量被劫持，或是日志文件被窃取，黑客不是一样可以拿到明文。

---------------------------------------------------

感觉前端加密没有任何必要，因为只要抓到包，就可以复现请求。（但是大佬们总结的避免枚举猜 id 的用处也还是很有用的，因为我也写过爬虫）

---------------------------------------------------

客户端做对称加密基本上是脱裤子放屁。做 md5 摘要并加盐（盐可以是静态的）可以避免服务端拿明文密码。

---------------------------------------------------

@halobabyy 重复请求个鬼啊，请求参数会加签的，就是防止重放攻击的，除非你破解别人的加签算法 .

---------------------------------------------------

安全角度，是通过各种手段，提高破坏的成本。
看场景决定使用哪些手段，只要风险可控就行，明文也没问题，比如非公开网络，非重要数据。

---------------------------------------------------

@vmebeh #30  那么攻击者也不需要知道密码明文,一样直接提供 密文就能完成登录.



我是觉的真要想前端加密,那么就用非对称算法加密, 前端只有公钥,没有私钥.后端再用私钥解密密码,然后在对原始密码加盐 hash 去比较数据库.

---------------------------------------------------

如果前端传给后端的只有 md5 而没有明文，那么只要这个 md5 被拿到，同样可以请求相同的接口登录成功，这和原始密码有什么区别吗？

---------------------------------------------------

前端把密码 md5 当然不是脱裤子放屁，把本来不定长度的字符串转化成定长的字符串，我如果想穷举密码，简直不要太开心。本来撞库还要跑一下彩虹表的，现在省了一步。

---------------------------------------------------

非对称加密下呗，公钥放前端加密，私钥服务端解密，中间人获取了数据也解密不了，反正不能明文传输，和裸奔没区别

---------------------------------------------------

这不说日经话题，算月经话题是可以的了吧。

---------------------------------------------------

先说结论，密码确实是要前端加密一下的。
不是说有 https 就可以万事大吉，它只是确保传输的时候不给盗窃，你怎么能确保传到服务器后不会泄露呢？
上面有人说既然服务器都被攻破了那还说个 JB ？
确实，但是只有被攻破才会泄露？
你的 NGINX 或者其他服务监控或者日志系统确定不会记录出入参？
只要有一个地方有记录密码，就会有泄露的可能。

---------------------------------------------------

看了一下 V2EX ，它就没加密

---------------------------------------------------

加密必要的前提是前端的混淆能不被逆向，如果能比逆向出来，公钥肯定也是写在前端里的。
像遇到的几个站，rsa 公钥加密，明文返回某对称加密私钥，然后后续用对称加密通讯。看着无懈可击，实际上公钥直接在源码里稍微逆向一下就搞到了，除了中间人一点用也没有。

感觉最好的办法还是用 jvmp 之类类似于抖音的加密/混淆，只能黑盒无法逆向，这时候才加解密才最有用

---------------------------------------------------

关于这个屁事，我就说一个看起来像是空话但估计很多程序员甚至很多安全人员都理解不了的结论：安全是一项多环节、多方位的系统工程，同时安全性又只是衡量信息系统的指标之一。如果不能用系统工程的方法来整体做安全，结果就是每个环节的草台班子都从“别人是比我更不靠谱的草台班子”的视角出发，极度不信任上下游，用各种山寨的、同时又是过度防御的所谓安全措施来把系统拖得无比复杂，影响业务可用和产品可维护性，并提高成本。

---------------------------------------------------

看情况：
1. 如果公司人不多，没有各种保密、合规要求，用了 https 的前提下，可以不加密
2. 如果公司人多，有保密、合规要求，要求尽量减少密码泄露的可能性，比如避免因为运维在网关打日志泄露密码，要用 https 和非对称加密（前端用公钥加密，后端只有一个服务可以有私钥解密）

---------------------------------------------------

当然有意义了。等保+密评的 表示  等保要求二级就建议在传输中进行加密处理。但此处的加密并不包含 md5 。 三级则是强制要求有加密。而且 md5 的你不要觉得不可逆。彩虹表只是目前还不够大而已。md5 再怎么不可逆。他也不算加密。他只是 hash 处理。不可逆不代表不会碰撞。

不管怎么样。就一句话。前后端都要加密。这个是基础中的基础。md5 也不是加密。这也是基础。简单的测试的时候都是直接在现场抓包看。不要说什么黑客无法在现场进行操作这种假设。现实中跳板机多了去了。

---------------------------------------------------

@adoal “极度不信任上下游”，我想说的意思是，同一个项目里不信任上下游的其他团队，甚至同一个团队里不信任上下游的其他角色。比如设计接口的人担心写业务代码实现的人没有安全意识顺手打 log 而 log 又会被运维的人随处乱放不妥善管理，所以传到业务逻辑实现处的信息先混淆或变换掉……特么的这不应该是团队治理要管的事么？当然现实中也确实有很多单位里做信息安全的部门是管不动业务部门信息化开发的，所以只能做各种渗透扫描、跨网段封管理端口和数据库端口、监听明文协议里的口令字段检查睿口令，然后发一堆整改报告等等。各种脱裤子放屁的扭曲安全设计，不一定对实际的安全有多大提高，但是对付安检倒是真的清净了。

---------------------------------------------------

有点用，但是用处不大，属于防君子不防小人的操作吧

---------------------------------------------------

不都短信登录， 或者扫码登录。 用密码的地方很少了。

---------------------------------------------------

你应该是指前端对明文密码进行 hash ，也就是用 hash 值作为密码，避免后端因为日志等原因导致用户原始密码泄露，从而被拿去撞库。

这里存在几个问题：

- 这种方式，唯一的作用就是密码传输的中间环节泄露后防止撞库其它应用。对用户而言，不同应用使用不同密码是个人信息安全的基本准则。对开发者而言，避免日志记录密码明文是常识。此外，密码明文在 TLS 的中间环节被泄露，而服务器却没有被攻破的场景太过理想。
- 这是一种魔改，不符合已有的密码认证协议，比如 Basic access authentication 。
- 对于多端应用，现有系统改造，需要废弃掉旧的应用版本。

简单来说，有用但没太大用，而且存在兼容性问题，以及升级成本。

---------------------------------------------------

确实是脱裤子放屁，某种程度上来说你 md5 后反而更不安全了，甭管你是否加盐，也甭管换啥更安全的 hash ，原本密码的不均匀的分布规律在 md5 后也一样不均匀，并且 md5 后的密码长度反而成为了固定值（ 128bits ），墒反而可能会降低，黑客可以确切的知道要 brute force 的密码格式；常用密码攻击也一样无法避免，原本用常用密码攻击，现在是用 hash 后的常用密码攻击

而且就像之前人所说的，如果黑客原本能拿到密码，那黑客现在也能拿到 hash ，而这个 hash 也一样是永久有效的，等同于密码

至于服务器 log ，如果 POST Body 都明文 log 下来了，那 hash 后的密码不也一样 log 下来了，而且很多同样敏感的 POST Body 也一样会 log 下来。这种属于 XY Problem ，应该去解决本质问题，而不是去其他地方脱裤子放屁

99%的情况下，没有学习过密码学的人自创的加密方法都是不安全的或者是没意义的。建议用现成的工具，比如 https 。确实明文传密码有不安全之处，此时的解决方案是去用 TOTP 、Passkey 这种成熟的加密解决方案（后者也涉及到“前端”加密），而不是去研究自创的前端加密这种脱裤子放屁的事

---------------------------------------------------

常规的解决方案就是前端不额外加密，密码直接 HTTPS 传，加盐 hash 后存数据库。我敢说绝大多数大厂的登录都是这样的。而且只要是 https 了，那就绝对不是“明文传输”了。如果 OP 觉得 devtools 里是明文有危险，那我可以告诉你，如果黑客都已经能读到这一层数据了，那直接监听键盘，或者直接读密码输入框都是可以做到的。

---------------------------------------------------

楼上都在假设密码在传输过程泄露，或者假设在服务端泄露。
那么泄露个 md5 加密后的密码和泄露原文密码有啥区别？
我直接拿泄露的 md5 加密后的密码去请求登录接口，同样可以换取 token 。
综上，有 https 的提前下，前端加密就是脱裤子放屁。（ Github 的登陆接口，前端传的就是明文）。
一切好听的话都是为了面试, 让面试官觉得你很注重细节罢了。

---------------------------------------------------

@mayday526 所以你看完我的帖子，泄露原文密码，用户多平台同一个密码，是不是很危险？泄露 md5 是可以换取 token ，只是这个应用被破解，但是只是泄露了一个密文。

---------------------------------------------------

@mayday526 完全胡说八道，拿到 md5 去请求，如果请求接口对所有请求参数做了加签，你怎么重放，你可以说破解加签算法，如果加签算法需要和后后端交互了。。。虽然安全只是相对的，拿到明文和拿到 md5 的结果当然不一样，撞库也不穷举所有密码，一个密码你不需要破解，一个你需要破解 10 年，是一样吗。

---------------------------------------------------

@ZE3kr 我这里加密的意义指的是避免密码原文泄露，而不是你所说的变成 md5 不安全，退一万步黑客破解了，那只是拿到了我的密文，而我原始密码没有泄露，像我多个平台都是同一个密码，原文被泄露了可以登陆我其他的应用。

---------------------------------------------------

我开发的登录页是在前端用公钥做了加密。

---------------------------------------------------

是

---------------------------------------------------

@Nosub 是滴，我的意思就是保证，用户入参之后将原始密码 md5+盐 加密起来，即便是泄露也拿不到原始密码，这样来避免撞库的情况。

---------------------------------------------------

这都能讨论这么久，一般场景下的前端加密不但愚蠢而且浪费性能。
你当前端代码用户端看不到吗？

有一种场景是另外，那就是前端代码是非常重要的资产，比如游戏，vr 视觉，那么前端代码和逻辑一般不想让别人看到，这时候代码加密并混淆以及 wasm 这些都是要用的。

还有人回答 RSA 、AES 这些， 这些已经是细枝末节了, 麻烦了解一些 Session key establishment protocols 和 一些 anthentication, https 主要是为了防止用户访问了假冒的网站，给你的网站信用背书。
安全不是仅仅靠加密算法，而是靠协议，要保证 key freshness 、effectiveness 、implicit key
authentication 、key confirmation 这几个条件。

---------------------------------------------------

防被脱库难道不是靠数据库加密存？前端散列只能防止服务端意外留下明文，其他时候没啥用

---------------------------------------------------

@userKamtao 用处微乎其微

1. 如果泄漏行为本身发生在前端（如恶意浏览器插件），那无论如何 hash 还是会泄漏原密码（读密码输入框/键盘事件），从而所有网站登录被攻破（无论是否前端加密）；
2. 原密码在其他未前端加密平台（是大多数网站）的后端或者传输层被泄漏，也一样可以计算出 hash 后的密文在你的平台上登录；
3. hash 后的密码在你的平台上的后端/传输层泄露，那所有用一样前端的前端加密算法的平台也一样可以登录了

下面考虑情况 3 ，能否每个网站做到不同的 hash ，从而实现每个网站的 hash 算法都不一样。这个可以做到（在 hash 前 append/prepend 一个平台 dependent 字符串就行）。但因为有 1-2 的存在所以 3 的意义有限。此外它带来的麻烦也不少，比如需要修改多个前端（不同客户端和网站）

而且我也提供了解决方案，直接用 Passkey 。用 Passkey 才是王道，而且绝大多数新版的 OS 都支持了

---------------------------------------------------

@gam2046 相当于穿了个麻花裤子

---------------------------------------------------

@Nosub 你没做过爬虫啊？第一步获取表单的所有字段，你的隐藏 sign 也拿得到。第二步组装再去发起请求直接获取 token 。所有操作都是基于脚本，验签即使加了时间差也没有问题。
什么重放攻击都是扯淡，我先获取表单的内容只要没有提交过给后端，都不属于重放攻击，都是模拟人为点击触发的。
什么加签算法跟后端交互，更是扯淡，先发起一个请求去后端换取 sign ，再拼接登录表单参数直接换取 token 。
只要基于表单的密码参数是泄露的前提下，换取 token 都是必然事件。

---------------------------------------------------

当你使用前端加密，并同时修改后端加密，以尽可能避免这些攻击时，你会发现你最终实现的东西是跟 Passkey 一样的。Passkey 不但不会泄漏原始密码，同时每次登陆所传输的东西还是不一样的

---------------------------------------------------

@ZE3kr   你说得不无道理，但每个网站和客户端对密码处理方式都不同，可以大大减少撞库概率。

---------------------------------------------------

@mayday526 要不我把我网站的 md5 和加盐的后的密码告诉你，你去模拟登陆看看。

---------------------------------------------------

记得在 V2 之前有人问过同样的问题，我这里也把上次看到的贴文 PO 下： https://blog.huli.tw/2023/01/10/security-of-encrypt-or-hash-password-in-client-side/

---------------------------------------------------

@Nosub 我费那个劲写个爬虫就为了给你证明密码已得的情况下重放攻击都是扯淡？我有病啊？
GitHub 登录账户和密码都是明文传输，你咋不去证明 GitHub 登录明文传输都是漏洞？

---------------------------------------------------

感觉，现在程序员的思考能力平均值，有所下降呢

---------------------------------------------------

@ZE3kr  感谢分享 PassKey ， 这又提供一个 安全协议可以分析，看了还是用了比较传统的验证身份信息以及 chanllenge response 模型。

---------------------------------------------------

@userKamtao #117 你怕是在滑天下之大稽哪个大厂敢在浏览器记录密码，你不会以为 remember me 是干这个事情的吗。

---------------------------------------------------

@izToDo 这个非常全面，感谢！

---------------------------------------------------

@lriushi  抱歉理解错了，github 和谷歌确实明文传递了，只是猜测会不会和谷歌浏览器的自动填充账号密码功能相关。

---------------------------------------------------

@userKamtao #178 普通人说出这个话我能理解，但是作为程序员呵呵呵呵。。。

---------------------------------------------------

我觉得严谨的大公司后台，肯定有一套防止前端明文不被内鬼开发或是日志提取的机制
但不是所有公司的后台都能做到

---------------------------------------------------

@shakoon #56 第七步打个日志就知道 X 了。然后你服务器上存的 F ？前面有 F ？

---------------------------------------------------

前段这么不信任服务器，https 和浏览环境，别密码了，所有的前端收集的敏感信息都加密一遍得了

---------------------------------------------------

chrome 都说过了，如果让贼人进了家里，再加个保险箱没啥意义。前端加密有意义，即用户的密码原始值只存在于用户的应用程序，不存在其他任何地方，应该用长度大于密码的不可逆算法去计算避免重复的情况，将原始值带离自己家都是增加风险的行为

---------------------------------------------------

twitter 不就干过把密码明文打进日志的事吗

/t/452464
看起来好几个大厂都干过，大厂干过的不一定一定是对的
盲目跟随有魅力的领袖，带来的很可能是灾难呢

---------------------------------------------------

@userKamtao #78 md5 这种算法在密码这种应用下彩虹表非常简单，暴力穷举都是可行的。

---------------------------------------------------

@kneo #79 多一个安全环节就多一个攻击面。

---------------------------------------------------

@dudubaba #83 接口请求日志啥都记下来？你们的日志系统没有 data masking ？这个问题更严重吧。你接口请求 cookie 记不记？用户表单里的电话地址身份证号记不记？

---------------------------------------------------

看到这里好像后端要明文的场景就一个密码强度校验么，共识也是不能明文入库。这么看前端做个 hash 好像不是很麻烦的事情，不过如果从大厂这种一个账号体系对应无数业务前端来看就会变得难做了，相对来说严格规范后端会更容易。结论上对自己服务器不是很有信心并且做单一产品的话是适合前端 hash 的。

---------------------------------------------------

大概和 Macbook 把内部结构 pcb 弄得那么漂亮差不多意义

